// Generated by CoffeeScript 1.4.0
var Handler;

Handler = {
  scriptIntervalID: null,
  delay: 60,
  stop: function() {
    if (Handler.scriptIntervalID) {
      return clearInterval(Handler.scriptIntervalID);
    }
  },
  start: function() {
    return Handler.scriptIntervalID = setInterval(Handler.main, Handler.delay);
  },
  main: function() {
    var HEIGHT, R, WIDTH, X0, Y0, anotherYoba, bumpedYoba, currentYoba, i, m1, m2, oL, oR, speed, v1, v2, yL, yR, yobaIndex, _i, _j, _len, _len1, _ref, _ref1, _ref2;
    WIDTH = canvas.width;
    HEIGHT = canvas.height;
    canvas.clear();
    _ref = Yoba.getAllYobas();
    for (yobaIndex = _i = 0, _len = _ref.length; _i < _len; yobaIndex = ++_i) {
      currentYoba = _ref[yobaIndex];
      X0 = currentYoba.position - currentYoba.radius;
      Y0 = HEIGHT - 2 * currentYoba.radius;
      R = currentYoba.radius;
      speed = currentYoba.speed;
      if (currentYoba.atRightBorder()) {
        speed = -Math.abs(speed);
      } else if (currentYoba.atLeftBorder()) {
        speed = +Math.abs(speed);
      }
      bumpedYoba = null;
      _ref1 = Yoba.getAllYobas();
      for (i = _j = 0, _len1 = _ref1.length; _j < _len1; i = ++_j) {
        anotherYoba = _ref1[i];
        if (i !== yobaIndex) {
          oR = anotherYoba.rightPoint();
          oL = anotherYoba.leftPoint();
          yR = currentYoba.rightPoint();
          yL = currentYoba.leftPoint();
          if ((oL <= yR && yR <= oR) || (oL <= yL && yL <= oR)) {
            bumpedYoba = anotherYoba;
          }
        }
      }
      if (bumpedYoba) {
        m1 = currentYoba.mass;
        m2 = bumpedYoba.mass;
        v1 = currentYoba.speed;
        v2 = bumpedYoba.speed;
        _ref2 = Handler.getSpeedsAfterBump(m1, v1, m2, v2), speed = _ref2[0], bumpedYoba.speed = _ref2[1];
        currentYoba.startSpeek();
        bumpedYoba.startSpeek();
      }
      currentYoba.continueSpeek();
      speed -= Handler.getFrictionalAcceleration(currentYoba.radius, currentYoba.mass, speed);
      currentYoba.angle = Handler.getNewAngle(currentYoba.angle, R, speed);
      currentYoba.position += Math.round(speed);
      currentYoba.speed = speed;
      currentYoba.redraw();
    }
    return Yoba.stopScriptIfAllStopped();
  },
  getSpeedsAfterBump: function(m1, v1, m2, v2) {
    return [((m1 - m2) * v1 + 2 * m2 * v2) / (m1 + m2), (2 * m1 * v1 + (m2 - m1) * v2) / (m1 + m2)];
  },
  getFrictionalAcceleration: function(R, M, speed) {
    var N, a, f;
    f = 0.3;
    N = 9.8 * M;
    a = (N * (f / R)) / R;
    if (speed > 0) {
      return a;
    } else {
      return -a;
    }
  },
  getNewAngle: function(a0, R, speed) {
    var dFi, fi;
    dFi = Math.round(speed) / R;
    fi = a0 + dFi;
    return 2 * Math.PI + fi % (4 * Math.PI);
  }
};
