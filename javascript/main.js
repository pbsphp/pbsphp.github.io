// Generated by CoffeeScript 1.4.0
var Handler;

Handler = {
  scriptIntervalID: null,
  delay: 60,
  stop: function() {
    if (Handler.scriptIntervalID) {
      return clearInterval(Handler.scriptIntervalID);
    }
  },
  start: function() {
    return Handler.scriptIntervalID = setInterval(Handler.main, Handler.delay);
  },
  main: function() {
    var bumpedYoba, currentYoba, m1, m2, v1, v2, _i, _len, _ref, _ref1;
    canvas.clear();
    _ref = Yoba.getAllYobas();
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      currentYoba = _ref[_i];
      if (currentYoba.atRightBorder()) {
        currentYoba.speed = -Math.abs(currentYoba.speed);
      } else if (currentYoba.atLeftBorder()) {
        currentYoba.speed = +Math.abs(currentYoba.speed);
      }
      bumpedYoba = currentYoba.getBumpedYoba();
      if (bumpedYoba) {
        m1 = currentYoba.mass;
        v1 = currentYoba.speed;
        m2 = bumpedYoba.mass;
        v2 = bumpedYoba.speed;
        _ref1 = Handler.getSpeedsAfterBump(m1, v1, m2, v2), currentYoba.speed = _ref1[0], bumpedYoba.speed = _ref1[1];
        currentYoba.startSpeek();
        bumpedYoba.startSpeek();
      }
      currentYoba.continueSpeek();
      currentYoba.speed -= Handler.getFrictionalAcceleration(currentYoba.radius, currentYoba.mass, currentYoba.speed);
      currentYoba.angle = Handler.getNewAngle(currentYoba.angle, currentYoba.radius, currentYoba.speed);
      currentYoba.position += Math.round(currentYoba.speed);
      currentYoba.redraw();
    }
    return Yoba.stopScriptIfAllStopped();
  },
  getSpeedsAfterBump: function(m1, v1, m2, v2) {
    return [((m1 - m2) * v1 + 2 * m2 * v2) / (m1 + m2), (2 * m1 * v1 + (m2 - m1) * v2) / (m1 + m2)];
  },
  getFrictionalAcceleration: function(R, M, speed) {
    var N, a, f;
    f = 0.3;
    N = 9.8 * M;
    a = (N * (f / R)) / R;
    if (speed > 0) {
      return a;
    } else {
      return -a;
    }
  },
  getNewAngle: function(a0, R, speed) {
    var dFi, fi;
    dFi = Math.round(speed) / R;
    fi = a0 + dFi;
    return 2 * Math.PI + fi % (4 * Math.PI);
  }
};
